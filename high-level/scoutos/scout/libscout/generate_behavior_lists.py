#!/usr/bin/python

# Usage:
#
# python generate_behavior_lists.py
#
# Parses to use only the final folder and file name for each source file.

import sys
import os

AUTOGEN_HEADER = '''/**
 ******************************************************************************
 * WARNING: THIS IS AN AUTOGENERATED FILE!
 *
 * Editing this file is USELESS. It will be overwritten during the build.
 * To properly edit this file, edit its corresponding *.template.* file, which
 * a script run by CMake uses to generate this file.
 *
 * This file was generated via rules in src/generate_behavior_lists.py.
 *
 * Please see that file for a description of syntax and procedure for
 * creating auto-generated files.
 *
 * THIS WARNING IS LONG TO MAKE SURE IT GETS YOUR ATTENTION!
 * THANK YOU.
 *****************************************************************************
 */

'''

# These are the codes this script will replace in template files.
FULL_PATH_CODE = 'AUTOGEN_BEHAVIOR_FULL_PATH'
LAST_PATH_CODE = 'AUTOGEN_BEHAVIOR_LAST_PATH'
BASE_NAME_CODE = 'AUTOGEN_BEHAVIOR_BASE_NAME'

# Different ways to refer to files in behaviors/ and test_behaviors/.
full_paths = []
last_paths = []
base_names = []

# Mapping of generated files to their templates
R_FILES = {'src/BehaviorList.cpp' : 'src/BehaviorList.template.cpp',
           'src/BehaviorList.h'   : 'src/BehaviorList.template.h'}

# Parse the src/behaviors and src/test_behaviors folders
cur_dir = os.getcwd()

all_paths = []
all_fnames = []
all_lasts = []

# Extract all the header files for behaviors we want
for path, dirname, fnames in os.walk('src'):
    if path == 'src/behaviors' or path == 'src/test_behaviors' or path.startswith("src/introlab"):
        path_parts = path.split('/')
        modified_path = path.lstrip("src/")
        for f in fnames:
            if f.endswith('.h'):
                all_paths.append(path)
                all_fnames.append(f)
                all_lasts.append(modified_path)

# Sort these headers into a good order and add them to our lists of paths/names
all_fnames, all_paths, all_lasts = (list(t) for t in zip(*sorted(zip(all_fnames, all_paths, all_lasts), key=lambda x: x[0].lower())))

for f, path, last in zip(all_fnames, all_paths, all_lasts):
    # Pause goes first
    if 'pause_scout' in f:
        full_paths.insert(0, os.path.join(cur_dir, path, f))
        last_paths.insert(0, os.path.join(last, f))
        base_names.insert(0, f.split('.')[0])
    # Everything else goes in alphabetical order
    else:
        full_paths.append(os.path.join(cur_dir, path, f))
        last_paths.append(os.path.join(last, f))
        base_names.append(f.split('.')[0])

# Now, a dictionary of codes to replace -> things to replace them with.
replacements = {FULL_PATH_CODE : full_paths,
                LAST_PATH_CODE : last_paths,
                BASE_NAME_CODE : base_names}

# also simultaneously write a txt file for the GUI to read from
with open("../scoutsim/behaviorList.txt", "w") as listFile:
    # Write all the replacements in R_FILES
    for outfile_name in sorted(R_FILES.keys()):
        with open(outfile_name, 'w') as outfile:
            with open(R_FILES[outfile_name], 'r') as infile:
                
                # Write an obvious header so no one will edit our nicely
                # generated file
                outfile.write(AUTOGEN_HEADER)

                for line in infile.readlines():
                    # If the line needs replacing, don't write the orgininal
                    # to the output file; rather, write many versions of the
                    # line replaced with each replacement value.
                    replaced = False
                    for r_key in replacements:
                        if r_key in line:
                            replaced = True
                            for b in replacements[r_key]:
                                outfile.write(line.replace(r_key, b))
                                if (r_key == BASE_NAME_CODE):
                                    listFile.write(b+"\n")
                    # If it doesn't need replacing, just write the original
                    if not replaced:
                        outfile.write(line)

    
